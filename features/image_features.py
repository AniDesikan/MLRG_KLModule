# # -*- coding: utf-8 -*-
# """Image_Features

# Automatically generated by Colaboratory.

# Original file is located at
#     https://colab.research.google.com/drive/1yjHY612QxVDg3H_1PdULmxcqR6Idjssl
# """


# from skimage import io, color, feature, filters
# import numpy as np
# import mahotas
# from joblib import Parallel, delayed

# class Image_Features:

#   def calculate_glcm(image, distance=1, angle=0, symmetric=True, normed=True):
#       """
#       Calculate Gray-Level Co-occurrence Matrix (GLCM) for a given image.

#       Parameters:
#       - image (np array): image array.
#       - distance (int): Pixel distance between samples (default: 1).
#       - angle (int): Angle in radians between samples (default: 0).
#       - symmetric (bool): Whether the GLCM is symmetric (default: True).
#       - normed (bool): Whether the GLCM is normalized (default: True).

#       Returns: 
#       - glcm (ndarray): Calculated GLCM.
#       """
#       # Read the image


#       # Convert the image to grayscale
#       gray_image = color.rgb2gray(image)
      
#       # Ensure the grayscale image is in the correct data type
#       gray_image = np.uint8(gray_image * 255)
#       gray_image = gray_image[0]
#       # print("Shape of gray_image:", gray_image.shape)

#       # Calculate GLCM
#       glcm = feature.greycomatrix(gray_image, [distance], [angle], symmetric=symmetric, normed=normed)

#       return glcm


#   def calculate_lbp(image, radius=1, n_points=8, method='default'):
#       """
#       Calculate Local Binary Pattern (LBP) for a given image.

#       Parameters:
#       - image (np array): image array.
#       - radius (int): Radius of LBP (default: 1).
#       - n_points (int): Number of points in LBP (default: 8).
#       - method (str): Method for calculating LBP ('default', 'ror', 'uniform', 'nri_uniform', 'var', 'nri_var').

#       Returns:
#       - lbp (ndarray): Calculated LBP matrix.
#       """

#       # Convert the image to grayscale
#       gray_image = color.rgb2gray(image)
#       gray_image = gray_image[0]
#       # Calculate LBP
      

#       gray_image =  np.uint8(gray_image * 255)
#       lbp = feature.local_binary_pattern(gray_image, P=n_points, R=radius, method=method)
#       lbp_hist, _ = np.histogram(lbp, bins=np.arange(0, 10), density=True)
#       lbp_features = lbp_hist

#       return lbp_features

#   def calculate_gabor_bank(images, orientations, scales, bandwidth):
#     """
#       Apply bank of Gabor filter to a given image. Will apply the filter for
#       each possible combination of orientations and scales for the image,
#       returning a new images whose channels will be each of these gabor response
#       maps.

#       Parameters:
#       - image (np array): image array.
#       - orientations (int): The number of angles of the filter between 0-pi/2
#       which should be calculated (angles will be evenly spaced).
#       - scales (int): the number of spatial frequencies for the filter between
#       0-H/2 (evenly spaced).
#       - bandwidth (float): Bandwidth of the Gabor filter.

#       Returns:
#       - gabor_response (ndarray): Calculated Gabor filter response. This array
#       will be of shape NxHxWx(orientations * scales).
#     """
#     theta = np.linspace(0,np.pi/2,orientations)
#     omega = np.linspace(0.1,1,scales)
#     gabor_images = []

#     for ind, val in enumerate(images):
#       gray_image = color.rgb2gray(val)
#       gray_image = gray_image[0]
#       ph = []
#       for th in theta:
#         for om in omega:
#           ph.append(filters.gabor(gray_image, om, th,bandwidth = bandwidth)[0])
#       gabor_images.append(np.stack(ph, axis=-1))

#     gabor_images = np.stack(gabor_images)

#     return gabor_images

#   def calculate_gabor_parallel(images, orientations, scales, bandwidth):
#     """
#     Apply bank of Gabor filter to a given image. Will apply the filter for
#     each possible combination of orientations and scales for the image,
#     returning a new images whose channels will be each of these gabor response
#     maps.

#     Parameters:
#     - image (np array): image array.
#     - orientations (int): The number of angles of the filter between 0-pi/2
#     which should be calculated (angles will be evenly spaced).
#     - scales (int): the number of spatial frequencies for the filter between
#     0-H/2 (evenly spaced).
#     - bandwidth (float): Bandwidth of the Gabor filter.

#     Returns:
#     - gabor_response (ndarray): Calculated Gabor filter response. This array
#     will be of shape NxHxWx(orientations * scales).
#     """
#     theta = np.linspace(0, np.pi/2, orientations)
#     omega = np.linspace(0.1, 1, scales)
#     gabor_images = []

#     def process_image(image):
#         gray_image = color.rgb2gray(image)
#         gray_image = gray_image[0]
#         ph = []
#         for th in theta:
#             for om in omega:
#                 ph.append(filters.gabor(gray_image, om, th, bandwidth=bandwidth)[0])
#         return np.stack(ph, axis=-1)

#     # Parallelize the processing of images
#     gabor_images = Parallel(n_jobs=-1)(delayed(process_image)(image) for image in images)
#     gabor_images = np.stack(gabor_images)

#     return gabor_images


#   def compute_hf(image, return_mean=False, ignore_zeros=False):
#     """
#     Returns the Haralick features of a set of images.
#     returns features of shape (grayscale: (n, 4, 13)), (colour: (n, 13, 13)),
#     and if return_mean=True, always returns an (n,13) array
#     """
#     gray_image =  np.uint8(color.rgb2gray(image) * 255)
#     gray_image = gray_image[0]
#     haralick = mahotas.features.haralick(gray_image)
#     haralick_features = np.mean(haralick, axis=0)

#     return haralick_features

#   def generate_image_features(images, do_glcm, do_lbp, use_haralick, distance,
#                               angle, radius, n_points, return_mean=False):
#     """
#     given a list of images and appropriate parameters, extracts features from
#     those images. Uses GLCM, LBP, and Haralick features.
#     params:
#     - images: np array or similar of images
#     - percent_glcm: float to calculate what percent of images use GLCM, percent
#     lbp is 1 - percent_glcm
#     - distance, angle: (floats) hyperparameters for compute_glcm
#     -  radius, n_points: (floats) hyperparameters for compute lbp
#     - use_haralick: (bool) whether or not to compute haralick features
#     - return_mean: (bool) hyperparamter for computer_haralick_features.
#     """
#     N = images.shape[0]
#     ims = []
#     lbp_ims = []
#     glcm_ims = []
#     haralick_features = []

#     for i in range(N):
#       if do_glcm:
#         img = Image_Features.calculate_glcm(images[i], distance=distance, angle=angle)
#         glcm_ims.append(img)
#       if do_lbp:
#         img = Image_Features.calculate_lbp(images[i], radius=radius, n_points=n_points)
#         lbp_ims.append(img)
        
#       if use_haralick:
#         img = Image_Features.compute_hf(images[i], return_mean)
#         haralick_features.append(img)

#     lbp_ims = np.array(lbp_ims)
#     glcm_ims = np.array(glcm_ims)
#     haralick_features = np.array(haralick_features)

#     return glcm_ims, lbp_ims, haralick_features

from skimage import io, color, feature, filters
import numpy as np
import mahotas

class Image_Features:

    @staticmethod
    def calculate_glcm(image, distance=1, angle=0, symmetric=True, normed=True):
        gray_image =  np.uint8(color.rgb2gray(image.squeeze()) * 255)
        glcm = feature.graycomatrix(gray_image, [distance], [angle], symmetric=symmetric, normed=normed)
        return glcm

    @staticmethod
    def calculate_lbp(image, radius=1, n_points=8, method='default'):
        gray_image =  np.uint8(color.rgb2gray(image.squeeze()) * 255)
        lbp = feature.local_binary_pattern(gray_image, P=n_points, R=radius, method=method)
        lbp_hist, _ = np.histogram(lbp.ravel(), bins=np.arange(0, n_points + 3), range=(0, n_points + 2), density=True)
        return lbp_hist

    @staticmethod
    def calculate_gabor_filter(image, orientations=8, scales=5, bandwidth=1):
        theta = np.linspace(0, np.pi, orientations, endpoint=False)
        frequencies = np.linspace(0.1, 0.5, scales)
        gray_image = color.rgb2gray(image.squeeze())
        gabor_features = []
        for frequency in frequencies:
            for angle in theta:
                filt_real, filt_imag = filters.gabor(gray_image, frequency=frequency, theta=angle, bandwidth=bandwidth)
                gabor_features.append(filt_real.mean())
                gabor_features.append(filt_imag.mean())
        return gabor_features

    @staticmethod
    def compute_hf(image, return_mean=False, ignore_zeros=False):
        gray_image =  np.uint8(color.rgb2gray(image.squeeze()) * 255)
        haralick = mahotas.features.haralick(gray_image)
        haralick_features = np.mean(haralick, axis=0)
        return haralick_features

    @staticmethod
    def generate_image_features(images, participation_factors, params):
        """
        Extract features from images using GLCM, LBP, Gabor filters, and Haralick features with specified participation factors.

        Parameters:
        - images (list of np.array): Images to process.
        - participation_factors (dict): A dictionary specifying the participation factor for each method, e.g., {'glcm': 0.3, 'lbp': 0.3, 'gabor': 0.4}.
        - params (dict): Parameters for each method.

        Returns:
        - A list of dictionaries with combined features for each image.
        """
        images = np.array(images)
        features_list = []

        for image in images:
            features = {}

            if participation_factors.get('glcm', 0) > 0:
                if params == None:
                    features['glcm'] = Image_Features.calculate_glcm(image)
                else:
                    features['glcm'] = Image_Features.calculate_glcm(image, **params.get('glcm', {}))

            if participation_factors.get('lbp', 0) > 0:
                if params == None:
                    features['lbp'] = Image_Features.calculate_lbp(image)
                else:
                    features['lbp'] = Image_Features.calculate_lbp(image, **params.get('lbp', {}))

            if participation_factors.get('haralick', 0) > 0:  # Assuming you want to include Haralick with its own participation factor
                features['haralick'] = Image_Features.compute_hf(image)

            features.flatten()
            features_list.append(features)

        return features_list


 
